================================================================================
GESTIONE DI MULTIPLI CLIENT - DOCUMENTAZIONE COMPLETA
================================================================================

DOMANDA: "Se dovessi gestire la connessione di piÃ¹ di un client come potrei fare?"

================================================================================
SOLUZIONE 1: LOOP INFINITO CON ACCEPT() - SOLUZIONE PIÃ™ SEMPLICE
================================================================================

Modificare Main.java cosÃ¬:

    package com.example;
    
    import java.io.IOException;
    import java.net.ServerSocket;
    import java.net.Socket;
    
    public class Main {
        public static void main(String[] args) throws IOException {
            ServerSocket ss = new ServerSocket(2000);
            
            System.out.println("Server in ascolto sulla porta 2000...");
            
            // Loop infinito per accettare piÃ¹ client
            while(true) {
                Socket s = ss.accept(); // Attende un client
                System.out.println("Nuovo client connesso!");
                
                MioThread m = new MioThread(s);
                m.start(); // Avvia il thread - ogni client ha il suo thread
            }
        }
    }

COME FUNZIONA:
- Ogni volta che un client si connette, viene creato un nuovo thread MioThread
- I thread paralleli permettono di gestire piÃ¹ client contemporaneamente
- Il loop continua ad accettare nuovi client indefinitamente


================================================================================
SOLUZIONE 2: THREADPOOL CON EXECUTORSERVICE - PIÃ™ EFFICIENTE
================================================================================

Per applicazioni con molti client:

    package com.example;
    
    import java.io.IOException;
    import java.net.ServerSocket;
    import java.net.Socket;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    
    public class Main {
        public static void main(String[] args) throws IOException {
            ServerSocket ss = new ServerSocket(2000);
            ExecutorService executor = Executors.newFixedThreadPool(10); // Max 10 client
            
            System.out.println("Server in ascolto sulla porta 2000...");
            
            while(true) {
                Socket s = ss.accept();
                System.out.println("Nuovo client connesso!");
                
                executor.execute(new MioThread(s)); // Assegna al pool di thread
            }
        }
    }

VANTAGGI: Limita il numero massimo di thread attivi, piÃ¹ efficiente con molti client.


================================================================================
SOLUZIONE 3: CHIUSURA CORRETTA DELLE RISORSE IN MIOTHREAD
================================================================================

Aggiungere try-finally per garantire la chiusura delle connessioni:

    @Override
    public void run() {
        Scanner scanner = new Scanner(System.in);   
        System.out.println("Client connesso!");
        out.println("Scegli un numero tra 0-100!");

        Random rand = new Random();
        int n = rand.nextInt(101);
        System.out.println(n);

        String line = "";   
        try {
            line = in.readLine();
            int numero = Integer.parseInt(line);

            if(numero == n) {
                out.println("Hai vinto!");
            } else {
                out.println("Hai perso!");
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                scanner.close();
                in.close();
                out.close();
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

IMPORTANTE: Il finally garantisce che le risorse vengano liberate anche in caso di errori.


================================================================================
SPIEGAZIONE DETTAGLIATA DEL LOOP (SOLUZIONE 1)
================================================================================

Analizzando il loop:

    while(true) {
        Socket s = ss.accept();           // â† PASSO 1
        System.out.println("Nuovo client connesso!");
        
        MioThread m = new MioThread(s);   // â† PASSO 2
        m.start();                        // â† PASSO 3
    }


PASSO 1: ss.accept()
-----------
â€¢ accept() Ã¨ un metodo BLOCCANTE (blocking)
â€¢ Il server si ferma qui e attende che un client si connetta
â€¢ Quando un client arriva, crea una nuova Socket e la assegna a s
â€¢ Poi il loop prosegue

Timeline esempio:
    Istante 0s: accept() â†’ Server in attesa...
    Istante 5s: Cliente A si connette â†’ accept() restituisce Socket_A
    Istante 5.1s: Esegue println() e crea thread
    Istante 5.2s: m.start() - avvia il thread
    Istante 5.3s: Torna al WHILE e richiama accept()
    Istante 8s: Cliente B si connette â†’ accept() restituisce Socket_B
                 (Nel frattempo Cliente A sta ancora giocando nel suo thread!)


PASSO 2: Creazione del Thread
-----------
â€¢ Crea un nuovo oggetto thread passandogli la Socket del client
â€¢ Questo thread sarÃ  dedicato SOLO a questo client
â€¢ La Socket rimane "legata" a quel thread specifico


PASSO 3: Avvio del Thread
-----------
â€¢ Avvia il thread in background
â€¢ NON Ã¨ bloccante: il thread comincia a girare separatamente
â€¢ Il loop continua immediatamente a eseguire il while


VISUALIZZAZIONE TEMPORALE CON PIÃ™ CLIENT
-----------
TEMPO     MAIN (accept loop)           THREAD CLIENT_A          THREAD CLIENT_B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
t=0s      accept() â† BLOCCO
t=1s      â†“ (in attesa)
t=2s      â†“ (in attesa)
t=3s      Client A arriva! âœ“
          Crea Thread_A âœ“
          m.start() âœ“
          accept() â† BLOCCO                Client_A partito!
t=4s      â†“ (in attesa)                    Aspetta numero...
t=5s      â†“ (in attesa)                    Riceve numero
t=6s      Client B arriva! âœ“               Calcola risultato
          Crea Thread_B âœ“                  Invia risposta
          m.start() âœ“                      âœ“ FINITO
          accept() â† BLOCCO                        Client_B partito!
t=7s      â†“ (in attesa)                           Aspetta numero...
t=8s      â†“ (in attesa)                           Riceve numero
                                                   Invia risposta


DIFFERENZA: CON vs SENZA LOOP
-----------
âŒ SENZA loop (come era prima):
    ServerSocket ss = new ServerSocket(2000);
    Socket s = ss.accept();      // Accetta 1 client
    MioThread m = new MioThread(s);
    m.start();
    // â† FINE PROGRAMMA! Il server muore!

â€¢ Accetta solo 1 client
â€¢ Poi termina tutto
â€¢ Client successivi ricevono "Connessione rifiutata"

âœ… CON loop (Soluzione 1):
    ServerSocket ss = new ServerSocket(2000);
    while(true) {                // LOOP INFINITO
        Socket s = ss.accept();  // Accetta client 1, 2, 3, 4...
        MioThread m = new MioThread(s);
        m.start();
        // Torna al while â† RE-ESEGUE accept()
    }

â€¢ Accetta infiniti client nel tempo
â€¢ Ogni uno ottiene il suo thread indipendente
â€¢ Il server non muore mai


================================================================================
PERCHÃ‰ MULTIPLI CLIENT SU UNA SOLA PORTA NON CREA ERRORI?
================================================================================

IDEA SBAGLIATA:
"Se due client usano la stessa porta 2000, non dovrebbero cozzare?"

LA REALTÃ€:
La porta 2000 Ã¨ solo il "numero civico" dove il server ascolta. 
Non Ã¨ il canale di comunicazione vero!


ANALOGIA CON UN UFFICIO POSTALE
-----------
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     UFFICIO POSTALE (Porta 2000)    â”‚
    â”‚                                     â”‚
    â”‚  ğŸ“¬ SPORTELLO DI RICEZIONE          |
    â”‚     (ServerSocket.accept())         â”‚
    â”‚                                     â”‚
    â”‚  âœ“ Cliente A entra â†’ Sportello 1    â”‚
    â”‚  âœ“ Cliente B entra â†’ Sportello 2    â”‚
    â”‚  âœ“ Cliente C entra â†’ Sportello 3    â”‚
    â”‚                                     â”‚
    â”‚  (Tutti entrano per la porta 2000)  â”‚
    â”‚  (Ma ogni uno ha il suo sportello)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

La porta 2000 Ã¨ l'ingresso unico, ma ogni client ottiene una connessione indipendente.


I 4 ELEMENTI DI UNA CONNESSIONE TCP
-----------
Ogni connessione TCP Ã¨ identificata da 4 parametri (tupla):

    (IP_Server, Porta_Server, IP_Client, Porta_Client)

Esempio con 2 client reali:

CLIENT A (IP: 192.168.1.100, Porta: 54321)
    â†“
    Connessione A: (192.168.1.50, 2000, 192.168.1.100, 54321)
    â†“
SERVER (IP: 192.168.1.50, Porta: 2000)

CLIENT B (IP: 192.168.1.101, Porta: 54322)
    â†“
    Connessione B: (192.168.1.50, 2000, 192.168.1.101, 54322)
    â†“
SERVER (IP: 192.168.1.50, Porta: 2000)

ANCHE SE ENTRAMBI USANO PORTA SERVER 2000, SONO CONNESSIONI DIVERSE PERCHÃ‰:
- IP_Client Ã¨ diverso (100 vs 101)
- Porta_Client Ã¨ diversa (54321 vs 54322)

Il sistema operativo distingue automaticamente!


COME FUNZIONA IN JAVA
-----------
    ServerSocket ss = new ServerSocket(2000);  // â† Una sola ServerSocket sulla porta 2000
    
    // Client A si connette
    Socket s1 = ss.accept();  // â† Restituisce Socket(IP_A, porta_A)
    
    // Client B si connette (mentre A Ã¨ ancora connesso)
    Socket s2 = ss.accept();  // â† Restituisce Socket(IP_B, porta_B)
                              // â† DIVERSA da s1!
    
    // Client C si connette
    Socket s3 = ss.accept();  // â† Restituisce Socket(IP_C, porta_C)
                              // â† DIVERSA sia da s1 che da s2!

Ogni Socket Ã¨ UNICA anche se il server ascolta su una sola porta.


DIAGRAMMA DEL FLOW
-----------
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ServerSocket ss = new ServerSocket(2000)   â”‚
    â”‚  â†‘                                           â”‚
    â”‚  (ascolta sulla porta 2000)                  â”‚
    â”‚                                              â”‚
    â”‚  while(true) {                              â”‚
    â”‚      Socket s = ss.accept();  â† ACCETTA     â”‚
    â”‚      â†“                                       â”‚
    â”‚    Ogni accept() crea una NUOVA Socket      â”‚
    â”‚    con combinazione IP/porta unica          â”‚
    â”‚                                              â”‚
    â”‚      MioThread m = new MioThread(s);        â”‚
    â”‚      m.start();  â† Thread indipendente      â”‚
    â”‚  }                                          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
        â†“ ss.accept() â† BLOCCANTE
        â”‚
        â”œâ”€ Cliente A si connette (192.168.1.100:54321)
        â”‚  â†’ Crea Socket s1
        â”‚  â†’ Crea Thread_A con s1
        â”‚  â†’ Thread_A legge/scrive su s1
        â”‚
        â”œâ”€ Cliente B si connette (192.168.1.101:54322)
        â”‚  â†’ Crea Socket s2
        â”‚  â†’ Crea Thread_B con s2
        â”‚  â†’ Thread_B legge/scrive su s2
        â”‚  (Nel frattempo Thread_A continua indipendente)
        â”‚
        â””â”€ Cliente C si connette (192.168.1.102:54323)
           â†’ Crea Socket s3
           â†’ Crea Thread_C con s3
           â†’ Thread_C legge/scrive su s3


COSA POTREBBE DARE ERRORE?
-----------
ERRORE: Aprire 2 ServerSocket sulla stessa porta:
    ServerSocket ss1 = new ServerSocket(2000);  // âœ“ OK
    ServerSocket ss2 = new ServerSocket(2000);  // âœ— ERRORE!
    // "Address already in use"

Ma con 1 ServerSocket e multiple Socket: âœ… PERFETTAMENTE OK!


TABELLA RIASSUNTIVA
-----------
Elemento                   | Quanti?         | Effetto
---------------------------|-----------------|----------------------------------------
ServerSocket(2000)         | 1 sola          | Ascolta in un'unica porta
Socket per client          | N illimitati    | Ogni client ha la sua connessione unica
Thread per client          | N illimitati    | Ogni thread gestisce indipendentemente
Porta server               | 1 sola          | Tanti client â†’ stessa porta, diversi 
                           |                 | IP/porta client

LA MAGIA:
Il sistema operativo e il protocollo TCP si incaricano di instradare correttamente 
i dati verso la giusta Socket in base alla TUPLA COMPLETA 
(IP_server, porta_server, IP_client, porta_client).


================================================================================
GESTIONE DELLA SCELTA DEL RANGE CON DO-WHILE
================================================================================

Il client deve scegliere il range (0-10, 0-100, 0-1000). Usa un do-while per 
ripetere la richiesta finchÃ© non fa una scelta valida:

    int r = 0; 
    boolean b = false;

    // Do-while con try-catch DENTRO per gestire input non validi
    do {
        try {
            out.println("scegli il range con cui giocare:");
            out.println("1. 0-10");
            out.println("2. 0-100");
            out.println("3. 0-1000");

            line = in.readLine();  // Legge la scelta del client
            int numero = Integer.parseInt(line);  // Converte a numero

            if(numero == 1){
                r = 11;  // Range per 0-10
                out.println("Scegli un numero tra 0-10!"); 
                b = true;  // Scelta valida, esce dal ciclo
            } 
            else if(numero == 2){
                r = 101;  // Range per 0-100
                out.println("Scegli un numero tra 0-100!"); 
                b = true;
            } 
            else if(numero == 3){
                r = 1001;  // Range per 0-1000
                out.println("Scegli un numero tra 0-1000!"); 
                b = true;
            }
            else {
                out.println("Scelta non valida! Riprova.");
                // b rimane false, il ciclo riprova
            }
            
        } catch (NumberFormatException e) {
            // Se il client invia un valore non numerico
            out.println("Errore! Inserisci un numero valido (1, 2 o 3).");
            // b rimane false, il ciclo riprova
        } catch (IOException e) {
            System.err.println("Errore nella comunicazione: " + e.getMessage());
            e.printStackTrace();
            break;  // Errore critico, esce dal ciclo
        }
    } while(!b);  // Ripete finchÃ© b Ã¨ false (scelta non valida)

KEY POINTS:
- b = true â†’ scelta valida, esce dal ciclo
- b rimane false â†’ scelta non valida, riprova
- NumberFormatException â†’ input non numerico, riprova
- IOException â†’ errore di rete critico, break e termina


================================================================================
GESTIONE DELLA SCELTA DEL NUMERO CON DO-WHILE
================================================================================

Dopo aver generato il numero casuale, il client lo deve indovinare. 
Usa un do-while per permettere al client di riprovare se inserisce input non valido:

    Random rand = new Random();
    int n = rand.nextInt(r);  // Genera numero in base al range
    System.out.println(n);

    boolean numeroValido = false;
    do {
        try {
            line = in.readLine();  // Legge il tentativo del client
            int numero = Integer.parseInt(line);  // Converte a numero

            if(numero == n){
                out.println("Hai vinto!");
            }
            else{
                out.println("Hai perso!");
            }
            numeroValido = true;  // Input valido, esce dal ciclo
            
        } catch (NumberFormatException e) {
            // Se il client invia un valore non numerico
            out.println("Errore! Inserisci un NUMERO valido.");
            numeroValido = false;  // Riprova
            
        } catch (IOException e) {
            System.err.println("Errore nella comunicazione: " + e.getMessage());
            e.printStackTrace();
            numeroValido = true;  // Errore critico, esce dal ciclo
        }
    } while(!numeroValido);  // Ripete finchÃ© non riceve un numero valido

KEY POINTS:
- numeroValido = true â†’ numero valido ricevuto, esce dal ciclo
- numeroValido = false â†’ input non numerico, riprova
- Il client puÃ² continuare a giocare finchÃ© non inserisce un numero valido


================================================================================
STRUTTURA CORRETTA: SEPARARE DO-WHILE DA FINALLY
================================================================================

IMPORTANTE: Se metti il do-while intorno al try-catch E hai un finally,
il finally si eseguirebbe ad OGNI ITERAZIONE (chiudendo la connessione
ogni volta). Questo Ã¨ SBAGLIATO!

SOLUZIONE: Separa il try-catch per la chiusura dal do-while:

    // ===== CICLO DO-WHILE (per gestire riprovare l'input) =====
    do {
        try {
            // logica del gioco
        } catch (NumberFormatException e) {
            // errore parsing
        } catch (IOException e) {
            // errore rete
        }
    } while(!condizioneEsci);  // â† CICLO CHIUDE QUI

    // ===== TRY-CATCH SEPARATO (per la chiusura risorse) =====
    // Si esegue UNA SOLA VOLTA dopo il ciclo
    try {
        // chiude scanner, in, out, socket
    } catch (IOException e) {
        // errore durante chiusura
    }

DIAGRAMMA:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  do {                   â”‚
    â”‚    try {                â”‚
    â”‚      logica gioco       â”‚
    â”‚    } catch (...) { }    â”‚
    â”‚  } while(!condizioneEsci) â† CICLO TERMINA
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  try {                  â”‚
    â”‚    chiude risorse       â”‚ â† Si esegue UNA SOLA VOLTA
    â”‚  } catch (...) { }      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VANTAGGI:
âœ… Il client puÃ² riprovare infinite volte
âœ… La chiusura avviene una sola volta alla fine
âœ… Separazione di responsabilitÃ  (logica vs. pulizia)


================================================================================
GESTIONE ERRORI: DIFFERENZA TRA NUMBERFORMATEXCEPTION E IOEXCEPTION
================================================================================

NumberFormatException:
- QUANDO: Integer.parseInt() riceve una stringa non numerica
- ESEMPIO: Client invia "abc" invece di "42"
- AZIONE: Inviare messaggio di errore, riprovare
- VALORE b/numeroValido: Rimane false (riprova il ciclo)

IOException:
- QUANDO: Problema di comunicazione di rete (client disconnesso, errore socket)
- ESEMPIO: Client chiude browser, problema connessione
- AZIONE: Log errore e termina il gioco
- VALORE b/numeroValido: Imposta a true (esce dal ciclo) o break

Struttura corretta:
    try {
        line = in.readLine();  // â† Potrebbe lanciare IOException
        int numero = Integer.parseInt(line);  // â† Potrebbe lanciare NumberFormatException
    } catch (NumberFormatException e) {
        // Input non valido, riprova
    } catch (IOException e) {
        // Problema di rete, termina
    }


================================================================================
CONSIGLIO FINALE
================================================================================

âœ… Usa la SOLUZIONE 1 (Loop infinito) per gestire multipli client
âœ… Usa do-while per OGNI input che il client deve dare
âœ… Separa il do-while dal try-catch di chiusura risorse
âœ… Gestisci NumberFormatException e IOException separatamente
âœ… Ricorda: try-catch di chiusura si esegue UNA SOLA VOLTA alla fine

================================================================================
